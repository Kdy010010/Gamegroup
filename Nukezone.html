<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nuke-Zone</title>
    <style>
        canvas { display: block; margin: 0 auto; background: #000; }
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const MAP_WIDTH = 500;
        const MAP_HEIGHT = 500;
        const TILE_SIZE = 64;
        const FOV = Math.PI / 3;
        const NUM_RAYS = canvas.width;
        const MAX_DEPTH = 800;
        const SPEED = 3;

        let player = {
            x: TILE_SIZE * 1.5,
            y: TILE_SIZE * 1.5,
            angle: 0,
            health: 100
        };

        let map = [];
        for (let i = 0; i < MAP_WIDTH; i++) {
            let row = [];
            for (let j = 0; j < MAP_HEIGHT; j++) {
                row.push(Math.random() < 0.1 ? 1 : 0);
            }
            map.push(row);
        }

        let bullets = [];
        let enemies = [
            { x: TILE_SIZE * 50, y: TILE_SIZE * 50, alive: true, shootCooldown: 0 }
        ];
        const enemyBullets = [];

        function castRays() {
            for (let i = 0; i < NUM_RAYS; i++) {
                let rayAngle = (player.angle - FOV / 2) + (i / NUM_RAYS) * FOV;
                let distance = raycast(player.x, player.y, rayAngle);
                drawWall(i, distance, rayAngle);
            }
        }

        function raycast(px, py, angle) {
            let cos = Math.cos(angle);
            let sin = Math.sin(angle);
            for (let depth = 0; depth < MAX_DEPTH; depth++) {
                let targetX = Math.floor((px + cos * depth) / TILE_SIZE);
                let targetY = Math.floor((py + sin * depth) / TILE_SIZE);
                if (map[targetY] && map[targetY][targetX] === 1) {
                    return depth;
                }
            }
            return MAX_DEPTH;
        }

        function drawWall(i, distance, angle) {
            const lineHeight = (TILE_SIZE / distance) * 277;
            const brightness = 1 - Math.min(distance / MAX_DEPTH, 1);
            ctx.fillStyle = `rgba(0, 255, 0, ${brightness})`;  // 초록색 벽
            ctx.fillRect(i, canvas.height / 2 - lineHeight / 2, 1, lineHeight);
        }

        function updateBullets() {
            for (let i = 0; i < bullets.length; i++) {
                bullets[i].x += Math.cos(bullets[i].angle) * SPEED * 3;
                bullets[i].y += Math.sin(bullets[i].angle) * SPEED * 3;
                ctx.fillStyle = 'red';
                ctx.fillRect(bullets[i].x, bullets[i].y, 5, 5);

                if (map[Math.floor(bullets[i].y / TILE_SIZE)][Math.floor(bullets[i].x / TILE_SIZE)] === 1) {
                    bullets.splice(i, 1);
                    i--;
                }
            }
        }

        function enemyShoot(enemy) {
            if (enemy.shootCooldown === 0) {
                let angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                enemyBullets.push({ x: enemy.x, y: enemy.y, angle: angle });
                enemy.shootCooldown = 100;
            }
        }

        function updateEnemyBullets() {
            enemyBullets.forEach((bullet, index) => {
                bullet.x += Math.cos(bullet.angle) * 5;
                bullet.y += Math.sin(bullet.angle) * 5;

                ctx.fillStyle = 'blue';
                ctx.fillRect(bullet.x, bullet.y, 5, 5);

                if (Math.hypot(bullet.x - player.x, bullet.y - player.y) < 10) {
                    player.health -= 10;
                    enemyBullets.splice(index, 1);
                }

                if (map[Math.floor(bullet.y / TILE_SIZE)][Math.floor(bullet.x / TILE_SIZE)] === 1) {
                    enemyBullets.splice(index, 1);
                }
            });
        }

        function updateEnemies() {
            enemies.forEach(enemy => {
                if (enemy.alive) {
                    let dx = player.x - enemy.x;
                    let dy = player.y - enemy.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 300) {
                        enemy.x += dx / dist;
                        enemy.y += dy / dist;

                        enemyShoot(enemy);
                    }

                    ctx.fillStyle = 'green';
                    ctx.fillRect(enemy.x, enemy.y, 10, 10);

                    if (enemy.shootCooldown > 0) {
                        enemy.shootCooldown--;
                    }
                }
            });
        }

        function drawHUD() {
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText('Health: ' + player.health, 20, 30);
        }

        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            castRays();
            updateBullets();
            updateEnemyBullets();
            updateEnemies();
            drawHUD();

            if (player.health > 0) {
                requestAnimationFrame(update);
            } else {
                ctx.font = '50px Arial';
                ctx.fillStyle = 'red';
                ctx.fillText('GAME OVER', canvas.width / 2 - 150, canvas.height / 2);
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') {
                player.x += Math.cos(player.angle) * SPEED;
                player.y += Math.sin(player.angle) * SPEED;
            }
            if (e.key === 'ArrowDown') {
                player.x -= Math.cos(player.angle) * SPEED;
                player.y -= Math.sin(player.angle) * SPEED;
            }
            if (e.key === 'ArrowLeft') {
                player.angle -= 0.1;
            }
            if (e.key === 'ArrowRight') {
                player.angle += 0.1;
            }
        });

        window.addEventListener('click', () => {
            bullets.push({
                x: player.x,
                y: player.y,
                angle: player.angle
            });
        });

        update();
    </script>
</body>
</html>
